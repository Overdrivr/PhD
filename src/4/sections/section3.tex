\section{Functionnal block checks}

In this section, another bottom-up method is proposed.
Like detailed previously, bottom-up methods are interesting for the intrisic modularity and reusability they offer.

In section 4.2, a block-failure modeling approach was detailed.
Mainly, it focused on modeling the failure of a block as a time and amplitude criteria on an input.
By going beyond the criteria, a failure was detected, and the output was considered at fault.
This fault was propagated then further in the system, to the input of the next block.
The main issue with this approach is the strong coupling between blocks.
To check that an input did not violate its failure criteria, you needed to know information about its surrounding blocks.

In this section, the method is also bottom-up but we focus instead on the signals inside the block itself, and not at its boundaries.
The idea is to write a set of rules or assertions on a few signals inside the block.
When those rules are violated, we know the block is in a faulty state.

This approach offers two main advantages compared to the section 4.2 method.

First, the rules are written logically based on the design of the block, and not arbitrarily defined.
If for instance a net is the gate command of a current mirror, a few criteria can be derived logically.
For the current mirror to function properly, at least 1 gate voltage is required for biasing.
Going below this voltage, the current mirror will not perform its copy anymore.

SCHEMATIC SIMPLE CURRENT MIRROR

Another example is taking a regulator.
If current drawn on the output of the regulator exceeds nominal capability, then the block will be considered faulty.

A set of simple rules could also be derived on supplies and ground.
For all blocks, supplies should be expected within a given range.
Grounds should be expected close to 0, and most likely lower than a body diode triggering voltage.

The second major advantage is that the rules are specific to a block.
They do not depend on boundary blocks, because they focus on the logical behavior of the block itself.
This means that this approach is highly modular and scalable.
Indeed, a set of rules written with an IP block can travel with it.
In any project/IC the block will be used, the rules will apply.

TALK ABOUT VIRTUAL TEST. DIFFERENCE IS VIRTUAL TEST IS INTERESTED IN INTER-BLOCK RELATIONSHIP ?

\subsection{Objective}

The objective of writing these assertions is to handle easily the inherent scale factor and complexity of an IC.
When performing simulations in soft-failure investigations, it became clear that the system, even with a few blocks,
was too complex to be analysed manually.
The amount of nets to check in order to ensure a block is operating normally is quite important.
Most blocks can have multiple current mirror, bias structures, etc. that can be in various states.

Automated checks help solve this issue, by enabling monitoring of a large amount of nets.
For the automated check to be useful, it needs to be performed in any simulation.
The following subsection details potential application of this technique, and how it should be setup to prove useful.

\subsection{Applicability and integration}

The main application the assertion approach was imagined for in this work is to detect blocks in failure state,
during an \gls{esd}.

However, this technique can have multiple different applications.
The major interest of these assertions would be to run them in any simulation, not just \gls{esd} simulations.

First, the file containing the assertions constitutes an electrical documentation of the block.
Any designer tasked with upgrading a block developped by someone else will immediately get a view of biasing levels,
expected current capabilities, etc.

Also, in a multi-person IC design team, a single block can be simulated by many different people (designer, verification, esd, etc.).
Those people will write testbenches to put those blocks into different situations.
Almost always, testbenches will take quite some time to be debugged, sometimes involving interaction with the original designer of the block.
Here, the assertion system can help avoid that, by highlighting when a block is not properly biased or operated.
Mistakes in testbenches will be easy to detect and understand, for anyone, without requiring the intervention of the original designer.

Also, some blocks require long startup sequence (slow ramp-up), usually regulators that power digital cells.
Those sequences can take an important simulation time.
Those long sequences are an issue if a testbench tries to validate some functionnality after startup.
To overcome this issue, some testbenches immediately put the block into its final DC state (using DC sources instead of ramp-up DC sources).
The problem with this approach is that in some cases the block will not be properly biased.
The assertion can help determine whether or not the block is in its final state and properly started.

Also, assertions can help detect early connection issues.
This is very useful for instance to detect floating ground.
A voltage criteria can be set on all ground nets, that will trigger a failure if a ground voltage exceeds for instance 1V.
This is very useful to detect unconnected nets, which can happen regurlarly with complex IC blocks that mix power functions, digital, analog
and usually have dedicated grounds for each domain.

Potential integration in Cadence environment
So far, limited support for assertions in Cadence.
In an ideal case, assertion files should be a specific view of the asserted cell.
This way, when the cell is copied or moved around, the assertions will move with it and be reused.

\subsection{Perks and Drawbacks}

Simple to write.
Reusable.
Integrates well into the design flow
General purpose (not limited to ESD, very useful in general considering all applications).

DRAWBACKS ?
Right amount of checks to write
Compare to unit tests in software design

\subsection{Proof of concept with a simple study-case}

EVEREST ?
SIMPLE CIRCUIT IN SIMULATION ?

\subsection{Proposed debugging interface}

User interface proposal for monitoring assertions.
Visualize when circuit is ready (all assertions are gree)
During and after ESD, which nets/blocks are disturbed first, how disturbances propagate inside the circuit.
