\section{Functionnal block checks}

% High level view of the new method
This section details a design method to detect functionnal failures early during the \gls{asic} design phase.
It is a bottom-up method like the one described in \ref{sec:bottom-up-modeling}.
However, the proposed method focuses on the signals inside the block itself, and not at its boundaries.

% Core principle
This method is loosely inspired from automated testing in the programming field, and electronics verification field.
The concept is to include inside any block schematic special cells (Fig. \ref{fig:ex-special-cells}), whose function is to raise a flag when certain conditions are met.
Basically, each cell performs a check.
The most simple check is asserting that a given net never crosses a given amplitude threshold.
If the condition is met, a flag is raised and timestamped.
The checking cells do not impact the electrical simulation.

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.3\textwidth]{src/4/figures/special_cells_concept.pdf}
  \caption{Example schematic with special checking cells}
  \label{fig:ex-special-cells}
\end{figure}

% Interest for ESD simulations
Powered-on \gls{asic} simulations can be difficult to investigate because of the scale factor.
At silicon-level, the ESD is injected through an external connection at the top-level.
\gls{asic} are very dense and complex devices, with multiple levels of hierarchy.
When a functionnal-failure appears, it propagates through that hierarchy, vertically (from top-level down to transistor-level) and horizontally (between blocks).
Except for a few obvious cases, this makes the investigation hard to perform.
Especially, there can be multiple places where the failure could be fixed.
In this context, knowing immediately which blocks raised flags, at which time and for how long is a precious information.

% Knowing which flags were raised
Knowing which blocks have raised flags shows where the ESD had an impact.
This information might seem obvious, but for a human being it is a very time-consuming to inspect most nets manually.

% Knowing when a flag starts
Furthermore, it was indicated that flags should be timestamped.
More specifically, the beginning and the end timestamps should be recorded.
The beginning of the flag indicates which block goes into failure first.
Sorting the beginning timestamps by ascending order indicates which block went into failure first, and in which order they were all impacted.
More concisely, the propagation of the disturbance through the complete system can be described with just this information.

% Knowing how long a flag was raised
%TODO: Continue
Finally, the duration of a flag provides a degree of severity of the flag.
Any flag that is a thousand times shorter than the original \gls{ESD} discharge indicates a very minor fault.
On the contrary, any flag that lasted larger than the discharge should indicate a very severe disturbance.

% Combined value of all this information
Combined together, smart decisions about where to fix the issues
Which block seem the most ESD sensitive

% How to write those flags


 this approach has many

When those rules are violated, we know the block is in a faulty state.

This approach offers two main advantages compared to the section 4.2 method.

First, the rules are written logicaly based on the design of the block, and not arbitrarily defined.
If for instance a net is the gate command of a current mirror, a few criteria can be derived logically.
For the current mirror to function properly, at least 1 gate voltage is required for biasing.
Going below this voltage, the current mirror will not perform its copy anymore.

SCHEMATIC SIMPLE CURRENT MIRROR

Another example is taking a regulator.
If current drawn on the output of the regulator exceeds nominal capability, then the block will be considered faulty.

A set of simple rules could also be derived on supplies and ground.
For all blocks, supplies should be expected within a given range.
Grounds should be expected close to 0, and most likely lower than a body diode triggering voltage.

The second major advantage is that the rules are specific to a block.
They do not depend on boundary blocks, because they focus on the logical behavior of the block itself.
This means that this approach is highly modular and scalable.
Indeed, a set of rules written with an IP block can travel with it.
In any project/IC the block will be used, the rules will apply.

TALK ABOUT VIRTUAL TEST. DIFFERENCE IS VIRTUAL TEST IS INTERESTED IN INTER-BLOCK RELATIONSHIP ?


\subsection{Applicability and integration}

The main application the assertion approach was imagined for in this work is to detect blocks in failure state,
during an \gls{esd}.

However, this technique can have multiple different applications.
The major interest of these assertions would be to run them in any simulation, not just \gls{esd} simulations.

First, the file containing the assertions constitutes an electrical documentation of the block.
Any designer tasked with upgrading a block developped by someone else will immediately get a view of biasing levels,
expected current capabilities, etc.

Also, in a multi-person IC design team, a single block can be simulated by many different people (designer, verification, esd, etc.).
Those people will write testbenches to put those blocks into different situations.
Almost always, testbenches will take quite some time to be debugged, sometimes involving interaction with the original designer of the block.
Here, the assertion system can help avoid that, by highlighting when a block is not properly biased or operated.
Mistakes in testbenches will be easy to detect and understand, for anyone, without requiring the intervention of the original designer.

Also, some blocks require long startup sequence (slow ramp-up), usually regulators that power digital cells.
Those sequences can take an important simulation time.
Those long sequences are an issue if a testbench tries to validate some functionnality after startup.
To overcome this issue, some testbenches immediately put the block into its final DC state (using DC sources instead of ramp-up DC sources).
The problem with this approach is that in some cases the block will not be properly biased.
The assertion can help determine whether or not the block is in its final state and properly started.

Also, assertions can help detect early connection issues.
This is very useful for instance to detect floating ground.
A voltage criteria can be set on all ground nets, that will trigger a failure if a ground voltage exceeds for instance 1V.
This is very useful to detect unconnected nets, which can happen regurlarly with complex IC blocks that mix power functions, digital, analog
and usually have dedicated grounds for each domain.

Potential integration in Cadence environment
So far, limited support for assertions in Cadence.
In an ideal case, assertion files should be a specific view of the asserted cell.
This way, when the cell is copied or moved around, the assertions will move with it and be reused.

\subsection{Perks and Drawbacks}

Simple to write.
Reusable.
Integrates well into the design flow
General purpose (not limited to ESD, very useful in general considering all applications).

DRAWBACKS ?
Right amount of checks to write
Compare to unit tests in software design

\subsection{Proof of concept with a simple study-case}

EVEREST ?
SIMPLE CIRCUIT IN SIMULATION ?

\subsection{Proposed debugging interface}

User interface proposal for monitoring assertions.
Visualize when circuit is ready (all assertions are gree)
During and after ESD, which nets/blocks are disturbed first, how disturbances propagate inside the circuit.
