\section{Functionnal block checks}

% Interest for ESD simulations
Powered-on \gls{asic} simulations can be difficult to investigate because of the scale factor.
At silicon-level, the ESD is injected through an external connection at the top-level.
\gls{asic} are very dense and complex devices, with multiple levels of hierarchy.
Disturbances propagate through the hierarchy, vertically (from top-level down to transistor-level) and horizontally (between blocks).
In case of failure, there can be multiple places where a fix could be applied.

% High level view of the new method
This section details a design method to detect functionnal failures early during the \gls{asic} design phase.
It is a bottom-up method like the one described in \ref{sec:bottom-up-modeling}.
However, the proposed method focuses on the signals inside the block itself, and not at its boundaries.

% Core principle
This method is loosely inspired from automated testing in the programming field.
The concept is to define for each block function a series of assertions.
An assertion is a condition that raises a flag if not respected.
Each time the block is instantiated into a testbench and simulated, the electrical simulator tests its assertions at each timestep.

% Knowing which flags were raised
Knowing which blocks have raised flags shows where the ESD had an impact.
This information might seem obvious, but for a human being it is a very time-consuming to inspect most nets and blocks manually.

% Knowing when a flag starts
The beginning time and end time of each failure are recorded.
Failures can be sorted with their beginning time by ascending order.
This sorted list indicates which block went into failure first, and in which order they were all impacted.
It gives a complete picture of the propagation of the disturbance through the complete system.

% Knowing how long a flag was raised
The duration of a flag provides an indication of its severity.
For instance, any flag that is a thousand times shorter than the original \gls{ESD} discharge indicates a very minor fault.
On the contrary, any flag that lasted larger than the discharge should indicate a very severe disturbance, and an aggravation of the original disturbance.

% Combined value of all this information
Combined together, those information enable to make smart decisions about where to fix the issues.
Blocks that are the most sensitive can be easily identified for hardening.

\subsection{Implementation}

These assertions can be implemented in different manners.

% Method using spectre-simulator checkers
The Spectre (TODO: To check?) simulator offers the possibility to build a list of assertions to check for a simulation.
This is not exactly the concept described in this section, because this list cannot be associated to a block but only to a simulation.
It can however enable to test this assertion system and the value of information obtained with it.

% Method using a dedicated view
Another option is to create a dedicated assertion view inside the block's cell.
This view takes the form of a text file containing a list of all assertions for the block.
Then, the simulator must be instructed to use this view if it exists and check the assertions defined in it.

% Method using in-schematic assertions
The last approach is to add directly in the schematic assertion cells (Fig. \ref{fig:ex-special-cells}).
Those cells can be implemented in any analog or mixed-signal \gls{hdl}, such as Verilog-A or VHDL-AMS.
Those cells are transparent for the simulator and do not impact the electrical simulation.

%TODO: Example Verilog-a code for special cell amplitude threshold cross
%TODO: Example Verilog-a code for current detection

\begin{figure}[!h]
  \centering
  \includegraphics[width=0.3\textwidth]{src/4/figures/special_cells_concept.pdf}
  \caption{Example schematic with special checking cells}
  \label{fig:ex-special-cells}
\end{figure}

% Comparison
Each method offers advantages and has inherent defaults.
Using the per-simulation assertions is fast and easy, but it must be repeated for each simulation.
It is not viable for implementing the proposed method.

The assertion view fits well into existing Cadence workflow.
Assertion views can be added to existing schematics without modification.
However, during the design phase, a block gets modified multiple times and by different people.
As a consequence of those modifications, old nets are removed, new nets are created and existing nets can be renamed.
For the assertion view to be useful, it would require designers to update it each time the schematic has been modified.
This extra amount of work, and requiring a designer to modify data in two places tend to indicate that an assertion view is not practical either.

The in-schematic assertions is the most designer-friendly solution.
Designers can easily create assertions between nets, modify them and remove them.
Overall, this option seems to be the most viable.

\subsection{Proof of concept}

% What is the study-case
The concept is tested in a first simulation.
The goal is to show with just a few assertions, the failure case of section \label{sec:failure-case-study} could have been understood more easily and quickly.

% What assertions
Only a few assertions are implemented per block.
The supplies and ground pins are checked against a voltage range.
Current mirrors are checked to ensure current is properly copied.
%TODO What else ?
%TODO: Table of assertion placements

% How is it checked
The Spectre simulator assertions are used for testing purposes.
%TODO: show the circuit
A XX V XX ns TLP pulse is injected on VBATT.
Failure is observed on V2p5

The assertions were recorded and given in table XXX

%TODO: Table of results

%TODO: Analyse the results
% Impacted blocks
% Sorted list
% Duration list

\subsection{Assertion writing}

Assertions are written logically based on the design of the block.
If for instance a net is the gate command of a current mirror, a few criteria can be derived logically.
For the current mirror to function properly, at least 1 gate voltage is required for biasing.
Going below this voltage, the current mirror will not perform its copy anymore.

SCHEMATIC SIMPLE CURRENT MIRROR

Another example is taking a regulator.
If current drawn on the output of the regulator exceeds nominal capability, then the block will be considered faulty.

A set of simple rules could also be derived on supplies and ground.
For all blocks, supplies should be expected within a given range.
Grounds should be expected close to 0, and most likely lower than a body diode triggering voltage.

The second major advantage is that the rules are specific to a block.
They do not depend on boundary blocks, because they focus on the logical behavior of the block itself.
This means that this approach is highly modular and scalable.
Indeed, a set of rules written with an IP block can travel with it.
In any project/IC the block will be used, the rules will apply.

TALK ABOUT VIRTUAL TEST. DIFFERENCE IS VIRTUAL TEST IS INTERESTED IN INTER-BLOCK RELATIONSHIP ?

\subsection{Applicability beyond ESD simulations}

The main application the assertion approach was imagined for in this work is to detect blocks in failure state,
during an \gls{esd}.

However, this technique can have multiple different applications.
The major interest of these assertions would be to run them in any simulation, not just \gls{esd} simulations.

First, the file containing the assertions constitutes an electrical documentation of the block.
Any designer tasked with upgrading a block developped by someone else will immediately get a view of biasing levels,
expected current capabilities, etc.

Also, in a multi-person IC design team, a single block can be simulated by many different people (designer, verification, esd, etc.).
Those people will write testbenches to put those blocks into different situations.
Almost always, testbenches will take quite some time to be debugged, sometimes involving interaction with the original designer of the block.
Here, the assertion system can help avoid that, by highlighting when a block is not properly biased or operated.
Mistakes in testbenches will be easy to detect and understand, for anyone, without requiring the intervention of the original designer.

Also, some blocks require long startup sequence (slow ramp-up), usually regulators that power digital cells.
Those sequences can take an important simulation time.
Those long sequences are an issue if a testbench tries to validate some functionnality after startup.
To overcome this issue, some testbenches immediately put the block into its final DC state (using DC sources instead of ramp-up DC sources).
The problem with this approach is that in some cases the block will not be properly biased.
The assertion can help determine whether or not the block is in its final state and properly started.

Also, assertions can help detect early connection issues.
This is very useful for instance to detect floating ground.
A voltage criteria can be set on all ground nets, that will trigger a failure if a ground voltage exceeds for instance 1V.
This is very useful to detect unconnected nets, which can happen regurlarly with complex IC blocks that mix power functions, digital, analog
and usually have dedicated grounds for each domain.

Potential integration in Cadence environment
So far, limited support for assertions in Cadence.
In an ideal case, assertion files should be a specific view of the asserted cell.
This way, when the cell is copied or moved around, the assertions will move with it and be reused.

\subsection{Perks and Drawbacks}

Simple to write.
Reusable.
Integrates well into the design flow
General purpose (not limited to ESD, very useful in general considering all applications).

DRAWBACKS ?
Right amount of checks to write
Compare to unit tests in software design

\subsection{Proposed debugging interface}

User interface proposal for monitoring assertions.
Visualize when circuit is ready (all assertions are gree)
During and after ESD, which nets/blocks are disturbed first, how disturbances propagate inside the circuit.
